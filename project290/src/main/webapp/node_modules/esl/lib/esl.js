// Generated by CoffeeScript 1.10.0
(function() {
  var FreeSwitchClient, FreeSwitchParser, FreeSwitchResponse, FreeSwitchServer, assert, connectionListener, debug, net, parse_header_text, pkg,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  connectionListener = function(call) {
    var parser;
    if (call.stats == null) {
      call.stats = {};
    }
    parser = new FreeSwitchParser(call.socket);
    call.on('CHANNEL_EXECUTE_COMPLETE', function(res) {
      var application, application_data, ref, unique_id;
      application = res.body['Application'];
      application_data = (ref = res.body['Application-Data']) != null ? ref : '';
      call.emit("CHANNEL_EXECUTE_COMPLETE " + application + " " + application_data, res);
      unique_id = res.body['Unique-ID'];
      if (unique_id != null) {
        return call.emit("CHANNEL_EXECUTE_COMPLETE " + unique_id + " " + application + " " + application_data, res);
      }
    });
    call.on('BACKGROUND_JOB', function(res) {
      var job_uuid;
      job_uuid = res.body['Job-UUID'];
      return call.emit_later("BACKGROUND_JOB " + job_uuid, {
        body: res.body._body
      });
    });
    parser.process = function(headers, body) {
      var base, base1, base2, base3, base4, base5, base6, base7, base8, content_type, error1, event, exception, i, len, msg, n, outcome, ref;
      content_type = headers['Content-Type'];
      if (content_type == null) {
        if ((base = call.stats).missing_content_type == null) {
          base.missing_content_type = 0;
        }
        call.stats.missing_content_type++;
        call.socket.emit('error', {
          when: 'Missing Content-Type',
          headers: headers,
          body: body
        });
        return;
      }
      switch (content_type) {
        case 'auth/request':
          event = 'freeswitch_auth_request';
          if ((base1 = call.stats).auth_request == null) {
            base1.auth_request = 0;
          }
          call.stats.auth_request++;
          break;
        case 'command/reply':
          event = 'freeswitch_command_reply';
          if (headers['Event-Name'] === 'CHANNEL_DATA') {
            body = headers;
            headers = {};
            ref = ['Content-Type', 'Reply-Text', 'Socket-Mode', 'Control'];
            for (i = 0, len = ref.length; i < len; i++) {
              n = ref[i];
              headers[n] = body[n];
              delete body[n];
            }
          }
          if ((base2 = call.stats).command_reply == null) {
            base2.command_reply = 0;
          }
          call.stats.command_reply++;
          break;
        case 'text/event-json':
          try {
            body = body.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
            body = JSON.parse(body);
          } catch (error1) {
            exception = error1;
            if ((base3 = call.stats).json_parse_errors == null) {
              base3.json_parse_errors = 0;
            }
            call.stats.json_parse_errors++;
            call.socket.emit('error', {
              when: 'JSON error',
              error: exception,
              body: body
            });
            return;
          }
          event = body['Event-Name'];
          break;
        case 'text/event-plain':
          body = parse_header_text(body);
          event = body['Event-Name'];
          if ((base4 = call.stats).events == null) {
            base4.events = 0;
          }
          call.stats.events++;
          break;
        case 'log/data':
          event = 'freeswitch_log_data';
          if ((base5 = call.stats).log_data == null) {
            base5.log_data = 0;
          }
          call.stats.log_data++;
          break;
        case 'text/disconnect-notice':
          event = 'freeswitch_disconnect_notice';
          if ((base6 = call.stats).disconnect == null) {
            base6.disconnect = 0;
          }
          call.stats.disconnect++;
          break;
        case 'api/response':
          event = 'freeswitch_api_response';
          if ((base7 = call.stats).api_responses == null) {
            base7.api_responses = 0;
          }
          call.stats.api_responses++;
          break;
        default:
          debug('Unhandled Content-Type', content_type);
          event = "freeswitch_" + (content_type.replace(/[^a-z]/, '_'));
          call.socket.emit('error', {
            when: 'Unhandled Content-Type',
            error: content_type
          });
          if ((base8 = call.stats).unhandled == null) {
            base8.unhandled = 0;
          }
          call.stats.unhandled++;
      }
      msg = {
        headers: headers,
        body: body
      };
      return outcome = call.emit(event, msg);
    };
    return call.emit('freeswitch_connect');
  };

  net = require('net');

  FreeSwitchServer = (function(superClass) {
    extend(FreeSwitchServer, superClass);

    function FreeSwitchServer(requestListener) {
      this.stats = {};
      this.on('connection', function(socket) {
        var base, call;
        if ((base = this.stats).connections == null) {
          base.connections = 0;
        }
        this.stats.connections++;
        call = new FreeSwitchResponse(socket);
        call.once('freeswitch_connect').then(function() {
          var error1, exception;
          try {
            return requestListener.call(call);
          } catch (error1) {
            exception = error1;
            return call.socket.emit('error', exception);
          }
        });
        return connectionListener(call);
      });
      FreeSwitchServer.__super__.constructor.call(this);
    }

    return FreeSwitchServer;

  })(net.Server);

  exports.server = function(options, handler, report) {
    var ref, server;
    if (options == null) {
      options = {};
    }
    if (typeof options === 'function') {
      ref = [{}, options, handler], options = ref[0], handler = ref[1], report = ref[2];
    }
    if (report == null) {
      report = options.report;
    }
    if (report == null) {
      report = function(error) {
        return debug("Server: " + error);
      };
    }
    assert.ok(handler != null, "server handler is required");
    assert.strictEqual(typeof handler, 'function', "server handler must be a function");
    server = new FreeSwitchServer(function() {
      var Unique_ID, base, error1, exception;
      try {
        Unique_ID = 'Unique-ID';
        if ((base = server.stats).connecting == null) {
          base.connecting = 0;
        }
        server.stats.connecting++;
        return this.connect().then(function(res) {
          this.data = res.body;
          this.uuid = this.data[Unique_ID];
          return this.filter(Unique_ID, this.uuid);
        }).then(function() {
          var base1;
          this.auto_cleanup();
          if ((base1 = server.stats).handler == null) {
            base1.handler = 0;
          }
          return server.stats.handler++;
        }).then(function() {
          return this.event_json('ALL');
        }).then(function() {
          return handler.apply(this, arguments);
        })["catch"](function() {
          return report.apply(this, arguments);
        });
      } catch (error1) {
        exception = error1;
        return report(exception);
      }
    });
    debug("Ready to start " + pkg.name + " " + pkg.version + " server.");
    return server;
  };

  FreeSwitchClient = (function(superClass) {
    extend(FreeSwitchClient, superClass);

    function FreeSwitchClient() {
      this.call = new FreeSwitchResponse(this);
      this.on('connect', (function(_this) {
        return function() {
          return connectionListener(_this.call);
        };
      })(this));
      FreeSwitchClient.__super__.constructor.call(this);
    }

    return FreeSwitchClient;

  })(net.Socket);

  exports.default_password = 'ClueCon';

  exports.client = function(options, handler, report) {
    var client, ref;
    if (options == null) {
      options = {};
    }
    if (typeof options === 'function') {
      ref = [{}, options, handler], options = ref[0], handler = ref[1], report = ref[2];
    }
    if (report == null) {
      report = options.report;
    }
    if (report == null) {
      report = function(error) {
        return debug("Client: " + error);
      };
    }
    if (options.password == null) {
      options.password = exports.default_password;
    }
    assert.ok(handler != null, "client handler is required");
    assert.strictEqual(typeof handler, 'function', "client handler must be a function");
    client = new FreeSwitchClient();
    client.call.once('freeswitch_auth_request').then(function() {
      return this.auth(options.password);
    }).then(function() {
      return this.auto_cleanup();
    }).then(function() {
      return this.event_json('CHANNEL_EXECUTE_COMPLETE');
    }).then(function() {
      return this.event_json('BACKGROUND_JOB');
    }).then(function() {
      return handler.apply(this, arguments);
    })["catch"](function() {
      return report.apply(this, arguments);
    });
    debug("Ready to start " + pkg.name + " " + pkg.version + " client.");
    return client;
  };

  assert = require('assert');

  FreeSwitchParser = require('./parser');

  FreeSwitchResponse = require('./response');

  parse_header_text = FreeSwitchParser.parse_header_text;

  pkg = require('../package.json');

  debug = (require('debug'))('esl:main');

}).call(this);
