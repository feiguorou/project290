// Generated by CoffeeScript 1.10.0
(function() {
  var EventEmitter, FreeSwitchError, FreeSwitchResponse, Promise, assert, debug, trace,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  FreeSwitchError = (function(superClass) {
    extend(FreeSwitchError, superClass);

    function FreeSwitchError(res1, args1) {
      this.res = res1;
      this.args = args1;
      FreeSwitchError.__super__.constructor.call(this, JSON.stringify(this.args));
    }

    return FreeSwitchError;

  })(Error);

  module.exports = FreeSwitchResponse = (function() {
    function FreeSwitchResponse(socket) {
      this.socket = socket;
      assert(this.socket != null, 'Missing socket parameter');
      this.ev = new EventEmitter();
      this.__queue = Promise.resolve(null);
      this.closed = false;
      this.socket.on('close', (function(_this) {
        return function() {
          _this.closed = true;
          trace('Socket closed');
          return _this.emit('socket-close');
        };
      })(this));
      this.socket.on('error', (function(_this) {
        return function(err) {
          debug('Socket Error', {
            err: err
          });
          return _this.emit('socket-error', err);
        };
      })(this));
      this.__later = {};
      null;
    }

    FreeSwitchResponse.prototype.error = function(res, data) {
      debug("error", {
        res: res,
        data: data
      });
      return Promise.reject(new FreeSwitchError(res, data)).bind(this);
    };

    FreeSwitchResponse.prototype.enqueue = function(f) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var fulfilled, rejected;
          fulfilled = function(p) {
            return resolve(p);
          };
          rejected = function(e) {
            return reject(e);
          };
          return _this.__queue = _this.__queue.then(function() {
            return f();
          }).then(fulfilled)["catch"](rejected);
        };
      })(this)).bind(this);
    };

    FreeSwitchResponse.prototype.emit = function() {
      var outcome, ref, ref1, ref2;
      trace('emit', arguments[0], {
        headers: (ref = arguments[1]) != null ? ref.headers : void 0,
        body: (ref1 = arguments[1]) != null ? ref1.body : void 0
      });
      outcome = (ref2 = this.ev).emit.apply(ref2, arguments);
      trace({
        emit: arguments[0],
        had_listeners: outcome
      });
      return outcome;
    };

    FreeSwitchResponse.prototype.once = function(event, cb) {
      var p;
      trace('create_once', event);
      p = new Promise((function(_this) {
        return function(resolve, reject) {
          var error1, exception;
          try {
            _this.ev.once(event, function() {
              trace('once', event, {
                data: arguments[0]
              });
              resolve.apply(null, arguments);
            });
            return null;
          } catch (error1) {
            exception = error1;
            return reject(exception);
          }
        };
      })(this));
      p = p.bind(this);
      if (event in this.__later) {
        this.emit(event, this.__later[event]);
        delete this.__later[event];
      }
      if (cb != null) {
        return p.then(cb);
      }
      return p;
    };

    FreeSwitchResponse.prototype.emit_later = function(event, data) {
      trace('emit_later', {
        event: event,
        data: data
      });
      if (!this.emit(event, data)) {
        return this.__later[event] = data;
      }
    };

    FreeSwitchResponse.prototype.on = function(event, callback) {
      trace('create_on', event);
      return this.ev.on(event, (function(_this) {
        return function() {
          trace('on', event, {
            data: arguments[0]
          });
          callback.apply(_this, arguments);
        };
      })(this));
    };

    FreeSwitchResponse.prototype.write = function(command, args) {
      var p;
      if (this.closed) {
        return this.error({}, {
          when: 'write on closed socket',
          command: command,
          args: args
        });
      }
      p = new Promise((function(_this) {
        return function(resolve, reject) {
          var error, error1, key, text, value;
          try {
            trace('write', {
              command: command,
              args: args
            });
            text = command + "\n";
            if (args != null) {
              for (key in args) {
                value = args[key];
                text += key + ": " + value + "\n";
              }
            }
            text += "\n";
            _this.socket.write(text, 'utf8');
            return resolve(null);
          } catch (error1) {
            error = error1;
            return reject(error);
          }
        };
      })(this));
      return p.bind(this);
    };

    FreeSwitchResponse.prototype.send = function(command, args) {
      if (this.closed) {
        return this.error({}, {
          when: 'send on closed socket',
          command: command,
          args: args
        });
      }
      return this.enqueue((function(_this) {
        return function() {
          var p, q;
          p = _this.once('freeswitch_command_reply').then(function(res) {
            var reply;
            if (res == null) {
              return;
            }
            trace('send: received reply', res, {
              command: command,
              args: args
            });
            reply = res.headers['Reply-Text'];
            if (reply == null) {
              trace('send: no reply', {
                command: command,
                args: args
              });
              return _this.error(res, {
                when: 'no reply to command',
                command: command,
                args: args
              });
            }
            if (reply.match(/^-/)) {
              debug('send: failed', reply, {
                command: command,
                args: args
              });
              return _this.error(res, {
                when: 'command reply',
                reply: reply,
                command: command,
                args: args
              });
            }
            trace('send: success', {
              command: command,
              args: args
            });
            return res;
          });
          q = _this.write(command, args);
          return q.then(function() {
            return p;
          });
        };
      })(this));
    };

    FreeSwitchResponse.prototype.end = function() {
      trace('end');
      this.closed = true;
      this.socket.end();
      return this;
    };

    FreeSwitchResponse.prototype.api = function(command) {
      trace('api', {
        command: command
      });
      if (this.closed) {
        return this.error({}, {
          when: 'api on closed socket',
          command: command
        });
      }
      return this.enqueue((function(_this) {
        return function() {
          var p, q;
          p = _this.once('freeswitch_api_response').then(function(res) {
            var ref, reply;
            if (res == null) {
              return;
            }
            trace('api: response', {
              command: command
            });
            reply = res.body;
            if (reply == null) {
              debug('api: no reply', {
                command: command
              });
              return _this.error(res, {
                when: 'no reply to api',
                command: command
              });
            }
            if (reply.match(/^-/)) {
              debug('api response failed', {
                reply: reply,
                command: command
              });
              return _this.error(res, {
                when: 'api response',
                reply: reply,
                command: command
              });
            }
            res.uuid = (ref = reply.match(/^\+OK ([\da-f-]{36})/)) != null ? ref[1] : void 0;
            return res;
          });
          q = _this.write("api " + command);
          return q.then(function() {
            return p;
          });
        };
      })(this));
    };

    FreeSwitchResponse.prototype.bgapi = function(command) {
      trace('bgapi', {
        command: command
      });
      if (this.closed) {
        return this.error({}, {
          when: 'bgapi on closed socket',
          command: command
        });
      }
      return this.send("bgapi " + command).then((function(_this) {
        return function(res) {
          var error, r, ref, reply;
          error = function() {
            return _this.error(res, {
              when: "bgapi did not provide a Job-UUID",
              command: command
            });
          };
          if (res == null) {
            return error();
          }
          reply = res.headers['Reply-Text'];
          r = reply != null ? (ref = reply.match(/\+OK Job-UUID: (.+)$/)) != null ? ref[1] : void 0 : void 0;
          if (r == null) {
            r = res.headers['Job-UUID'];
          }
          if (r == null) {
            return error();
          }
          trace('bgapi retrieve', r);
          return _this.once("BACKGROUND_JOB " + r);
        };
      })(this));
    };

    FreeSwitchResponse.prototype.event_json = function() {
      var events;
      events = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.send("event json " + (events.join(' ')));
    };

    FreeSwitchResponse.prototype.nixevent = function() {
      var events;
      events = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.send("nixevent " + (events.join(' ')));
    };

    FreeSwitchResponse.prototype.noevents = function() {
      return this.send("noevents");
    };

    FreeSwitchResponse.prototype.filter = function(header, value) {
      return this.send("filter " + header + " " + value);
    };

    FreeSwitchResponse.prototype.filter_delete = function(header, value) {
      if (value != null) {
        return this.send("filter delete " + header + " " + value);
      } else {
        return this.send("filter delete " + header);
      }
    };

    FreeSwitchResponse.prototype.sendevent = function(event_name, args) {
      return this.send("sendevent " + event_name, args);
    };

    FreeSwitchResponse.prototype.auth = function(password) {
      return this.send("auth " + password);
    };

    FreeSwitchResponse.prototype.connect = function() {
      return this.send("connect");
    };

    FreeSwitchResponse.prototype.linger = function() {
      return this.send("linger");
    };

    FreeSwitchResponse.prototype.exit = function() {
      return this.send("exit");
    };

    FreeSwitchResponse.prototype.log = function(level) {
      if (level != null) {
        return this.send("log " + level);
      } else {
        return this.send("log");
      }
    };

    FreeSwitchResponse.prototype.nolog = function() {
      return this.send("nolog");
    };

    FreeSwitchResponse.prototype.sendmsg_uuid = function(uuid, command, args) {
      var execute_text, options;
      options = args != null ? args : {};
      options['call-command'] = command;
      execute_text = uuid != null ? "sendmsg " + uuid : 'sendmsg';
      return this.send(execute_text, options);
    };

    FreeSwitchResponse.prototype.sendmsg = function(command, args) {
      return this.sendmsg_uuid(null, command, args);
    };

    FreeSwitchResponse.prototype.execute_uuid = function(uuid, app_name, app_arg, loops) {
      var options;
      options = {
        'execute-app-name': app_name,
        'execute-app-arg': app_arg
      };
      if (loops != null) {
        options.loops = loops;
      }
      return this.sendmsg_uuid(uuid, 'execute', options);
    };

    FreeSwitchResponse.prototype.command_uuid = function(uuid, app_name, app_arg) {
      var event, result;
      if (app_arg == null) {
        app_arg = '';
      }
      event = uuid != null ? "CHANNEL_EXECUTE_COMPLETE " + uuid + " " + app_name + " " + app_arg : "CHANNEL_EXECUTE_COMPLETE " + app_name + " " + app_arg;
      result = this.once(event);
      return this.execute_uuid(uuid, app_name, app_arg).then(function() {
        return result;
      });
    };

    FreeSwitchResponse.prototype.hangup_uuid = function(uuid, hangup_cause) {
      var options;
      if (hangup_cause == null) {
        hangup_cause = 'NORMAL_UNSPECIFIED';
      }
      options = {
        'hangup-cause': hangup_cause
      };
      return this.sendmsg_uuid(uuid, 'hangup', options);
    };

    FreeSwitchResponse.prototype.unicast_uuid = function(uuid, args) {
      return this.sendmsg_uuid(uuid, 'unicast', args);
    };

    FreeSwitchResponse.prototype.execute = function(app_name, app_arg) {
      return this.execute_uuid(null, app_name, app_arg);
    };

    FreeSwitchResponse.prototype.command = function(app_name, app_arg) {
      return this.command_uuid(null, app_name, app_arg);
    };

    FreeSwitchResponse.prototype.hangup = function(hangup_cause) {
      return this.hangup_uuid(null, hangup_cause);
    };

    FreeSwitchResponse.prototype.unicast = function(args) {
      return this.unicast_uuid(null, args);
    };

    FreeSwitchResponse.prototype.auto_cleanup = function() {
      var linger_delay;
      this.once('freeswitch_disconnect_notice', (function(_this) {
        return function(res) {
          trace('auto_cleanup: Received ESL disconnection notice', res);
          switch (res.headers['Content-Disposition']) {
            case 'linger':
              trace('Sending freeswitch_linger');
              return _this.emit('freeswitch_linger');
            case 'disconnect':
              trace('Sending freeswitch_disconnect');
              return _this.emit('freeswitch_disconnect');
            default:
              trace('Sending freeswitch_disconnect');
              return _this.emit('freeswitch_disconnect');
          }
        };
      })(this));
      linger_delay = 4000;
      this.once('freeswitch_linger', function() {
        trace('auto_cleanup/linger');
        if (this.emit('cleanup_linger')) {
          return debug('auto_cleanup/linger: cleanup_linger processed, make sure you call exit()');
        } else {
          trace("auto_cleanup/linger: exit() in " + linger_delay + "ms");
          return Promise.delay(linger_delay).bind(this).then(function() {
            trace('auto_cleanup/linger: exit()');
            return this.exit();
          })["catch"](function(error) {
            return debug("auto_cleanup/linger: exit() error: " + error + " (ignored)");
          });
        }
      });
      this.once('freeswitch_disconnect', function() {
        trace('auto_cleanup/disconnect');
        if (this.emit('cleanup_disconnect', this)) {
          return debug('auto_cleanup/disconnect: cleanup_disconnect processed, make sure you call end()');
        } else {
          trace('auto_cleanup/disconnect: end()');
          return this.end();
        }
      });
      return null;
    };

    return FreeSwitchResponse;

  })();

  Promise = require('bluebird');

  assert = require('assert');

  EventEmitter = require('events').EventEmitter;

  debug = (require('debug'))('esl:response');

  trace = (require('debug'))('esl:response:trace');

}).call(this);
